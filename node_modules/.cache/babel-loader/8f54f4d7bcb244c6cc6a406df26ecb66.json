{"ast":null,"code":"import { appendErrors as r } from \"react-hook-form\";\nimport { validateFieldsNatively as e, toNestErrors as o } from \"@hookform/resolvers\";\nvar n = function n(e, o) {\n    for (var n = {}; e.length;) {\n      var t = e[0],\n        s = t.code,\n        i = t.message,\n        a = t.path.join(\".\");\n      if (!n[a]) if (\"unionErrors\" in t) {\n        var u = t.unionErrors[0].errors[0];\n        n[a] = {\n          message: u.message,\n          type: u.code\n        };\n      } else n[a] = {\n        message: i,\n        type: s\n      };\n      if (\"unionErrors\" in t && t.unionErrors.forEach(function (r) {\n        return r.errors.forEach(function (r) {\n          return e.push(r);\n        });\n      }), o) {\n        var c = n[a].types,\n          f = c && c[t.code];\n        n[a] = r(a, o, n, s, f ? [].concat(f, t.message) : t.message);\n      }\n      e.shift();\n    }\n    return n;\n  },\n  t = function t(r, _t, s) {\n    return void 0 === s && (s = {}), function (i, a, u) {\n      try {\n        return Promise.resolve(function (o, n) {\n          try {\n            var a = Promise.resolve(r[\"sync\" === s.mode ? \"parse\" : \"parseAsync\"](i, _t)).then(function (r) {\n              return u.shouldUseNativeValidation && e({}, u), {\n                errors: {},\n                values: s.raw ? i : r\n              };\n            });\n          } catch (r) {\n            return n(r);\n          }\n          return a && a.then ? a.then(void 0, n) : a;\n        }(0, function (r) {\n          if (function (r) {\n            return null != r.errors;\n          }(r)) return {\n            values: {},\n            errors: o(n(r.errors, !u.shouldUseNativeValidation && \"all\" === u.criteriaMode), u)\n          };\n          throw r;\n        }));\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    };\n  };\nexport { t as zodResolver };","map":null,"metadata":{},"sourceType":"module"}